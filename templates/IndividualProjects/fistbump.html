<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/IndividualProjects/fistbump.css') }}">
    <title>Fistbump</title>
</head>
<body>
    <div> 
        <header class="header">
            <a href="/" class="nav-text">Home</a>
            <nav class="nav-bar">
                <a href="/about" class="nav-text">About Me</a>
                <a href="/projects" class="nav-text">Projects</a>
            </nav>
        </header>
        <main id="infinite-content">
            <div style="text-align: center;">
                <img class="img-background" src="{{ url_for('static', filename='images/fistbumpHome.jpeg') }}" alt="fistbump home page">
            </div>

            <div class="selector-content">
                <div class="page-row-section">
                    <div style="margin-top: 100px; margin-bottom: 100px; margin-left: 350px; margin-right: 350px;">
                        <p1 class="page-text"> Fistbump is a social networking app that links you with other users. Each day, you recieve 1 random user, with whom you must meet up with in person, and take a picture with them. After this, your image is shared to the wall, where everyone can see connections being made with their friends. This short act of meeting up to take your Fistbump together finishes the hardest step of meeting new people: Breaking the ice. After meeting each other, the two users are physically close and have talked, and this small connection could lead to more conversations, activities done together, shared phone numbers, and eventually, a new friendship.</p1>
                    </div>
                </div>
            </div>
            <div class="selector-content">
                <div class="page-row-section" style="margin-bottom: 100px;">
                    <img style="margin-right: 100px;" class="img-vertical" src="{{ url_for('static', filename='images/fistbumpProfile.jpeg') }}" alt="fistbump profile page">
                    <img style="margin-left: 100px;" class="img-vertical" src="{{ url_for('static', filename='images/fistbumpPhoto.jpeg') }}" alt="fistbump picture page">
                </div>
            </div>
            <div class="page-column-section" style="position: relative; height: 100vh;">
                <div class="buffer-zone page-row-section" style="display: flex; align-items: flex-end; height: 100%;"> 
                    <button class="load-button" style="margin-top: auto;">
                        <img class="buffer-img" style="position: relative;" src="{{ url_for('static', filename='images/slim_down_arrow.png') }}">
                    </button>
                    <p class="buffer-text" aria-hidden="true">Placeholder<br>Text</p>
                </div>
            </div>
            <div id="next-page-preview" class="hidden"></div>
        </main>
    </div>

    <div id="loading" style="display: none;">Loading...</div>
    <div id="input-blocker" class="hidden"></div>
    
    <script>

        const pages = [
                '/fistbump',
                '/stockSentiment',
                '/andersonCodingClub'
            ];
            let currentPageIndex = 0;
            let loading = false;
            let nextPageContent = '';
            let isPreviewFetchNextPage = false;
            let initialPageIndex = pages.indexOf(window.location.pathname);

            if (initialPageIndex === -1) {
                initialPageIndex = 0; 
            }

            currentPageIndex = initialPageIndex;

            const disableDownScroll = (event) => {
                if (event.deltaY > 0 || event.key === 'ArrowDown') {
                    event.preventDefault();
                }
            };

            const disableAllScroll = () => {
                document.body.classList.add('no-scroll');
            };

            const enableScroll = () => {
                window.removeEventListener('wheel', disableDownScroll, { passive: false });
                window.removeEventListener('keydown', disableDownScroll, { passive: false });
                document.body.classList.remove('no-scroll');
            };

            const blockUserInputs = () => {
                document.getElementById('input-blocker').classList.add('active');
            };

            const unblockUserInputs = () => {
                document.getElementById('input-blocker').classList.remove('active');
            };

            const attachEventListenersToButton = (button) => {
                button.addEventListener('mouseover', previewNextPage); 
                button.addEventListener('mouseleave', hideNextPage);   
                button.addEventListener('click', loadMoreContent);      
            };


            const smoothScrollTo = (y, duration, callback) => {
                const infiniteContent = document.getElementById('infinite-content');
                const inputBlocker = document.getElementById('input-blocker');
                const padding = 800;
                infiniteContent.style.paddingTop = `${padding}px`;

                window.scrollTo(0, 0)

                const startY = window.scrollY;
                const distance = y - startY;

                let startTime = null;

                function easeOutCubic(t) {
                    return 1 - Math.pow(1 - t, 3);
                }

                function scrollStep(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const progress = timestamp - startTime;
                    const percent = Math.min(progress / duration, 1);
                    const easedPercent = easeOutCubic(percent);
                    
                    window.scrollTo(0, startY + distance * easedPercent);

                    const exponentialPadding = padding * (1 - easedPercent);
                    infiniteContent.style.paddingTop = `${exponentialPadding}px`;

                    if (progress < duration) {
                        window.requestAnimationFrame(scrollStep);
                    } else {
                        infiniteContent.style.paddingTop = '0px';
                        if (callback) {
                            callback();
                        }
                        unblockUserInputs();
                        enableScroll();
                    }
                }
                blockUserInputs();
                disableAllScroll();
                window.requestAnimationFrame(scrollStep);
            };


            const loadMoreContent = () => {
                if (loading) return;
                loading = true;
                document.getElementById('loading').style.display = 'block';

                blockUserInputs();
                disableAllScroll();


                currentPageIndex = (currentPageIndex + 1) % pages.length;
                fetch(pages[currentPageIndex])
                    .then(response => response.text())
                    .then(data => {
                        const parser = new DOMParser();
                        const newDocument = parser.parseFromString(data, 'text/html');
                        const newContent = newDocument.getElementById('infinite-content').innerHTML;
                        const newContentContainer = document.createElement('div');
                        newContentContainer.innerHTML = newContent;

                        const oldContent = document.querySelectorAll('#infinite-content > div:not(#next-page-preview)');
                        oldContent.forEach(element => element.classList.add('hidden-content'));

                        document.getElementById('infinite-content').appendChild(newContentContainer);
                        document.getElementById('loading').style.display = 'none';
                        loading = false;

                        smoothScrollTo(0, 1500, () => {
                            const oldContent = document.querySelectorAll('#infinite-content > div:not(:last-child)');
                            oldContent.forEach(element => element.classList.add('hidden-content'));
                        });

                        const newButton = newContentContainer.querySelector('.load-button');
                        attachEventListenersToButton(newButton);


                        const newCSSUrl = newDocument.querySelector('link[rel="stylesheet"]').getAttribute('href');
                        document.querySelector('link[rel="stylesheet"]').setAttribute('href', newCSSUrl);

                        prefetchNextPage();

                    })
                    .catch(error => {
                        console.error('Failed to load content:', error);
                        document.getElementById('loading').style.display = 'none';
                        loading = false;
                        unblockUserInputs();
                        enableScroll();
                    });
            };

            const prefetchNextPage = () => {
                const nextPageIndex = (currentPageIndex + 1) % pages.length;
                fetch(pages[nextPageIndex])
                    .then(response => response.text())
                    .then(data => {
                        const parser = new DOMParser();
                        const newDocument = parser.parseFromString(data, 'text/html');
                        nextPageContent = newDocument.getElementById('infinite-content').innerHTML; 
                    })
                    .catch(error => {
                        console.error('Failed to prefetch next page:', error);
                    });
            };

            const previewNextPage = () => {
                if (nextPageContent) {
                    const buffEl = document.querySelector('.buffer-zone');
                    buffEl.classList.add('buffer-zone-move');
                    const nextPagePreview = document.getElementById('next-page-preview');
                    nextPagePreview.innerHTML = nextPageContent;
                    nextPagePreview.classList.remove('hidden'); 
                    nextPagePreview.style.display = 'block';
                    nextPagePreview.style.animation = 'scrollUp 0.5s forwards';
                    isPreviewFetchNextPage = true;
                    disableAllScroll();
                } else {
                    console.warn('No content to preview');
                }
            };

            const hideNextPage = () => {
                const buffEl = document.querySelector('.buffer-zone');
                buffEl.classList.remove('buffer-zone-move');
                const nextPagePreview = document.getElementById('next-page-preview');
                
                nextPagePreview.style.animation = 'scrollOut 0.5s forwards';
                
                nextPagePreview.addEventListener('animationend', () => {
                    nextPagePreview.classList.add('hidden');
                    nextPagePreview.style.display = 'none';
                    enableScroll();

                }, { once: true });
                
                isPreviewFetchNextPage = false;
            };

            document.addEventListener('DOMContentLoaded', () => {
                function checkVisibility() {
                    const elements = document.querySelectorAll('.selector-content');
                    elements.forEach(footerEl => {
                        const rect = footerEl.getBoundingClientRect();
                        if (rect.bottom <= (window.innerHeight + 150)) {
                            footerEl.classList.add('visible-selector-content');
                        }
                    });
                }
                window.addEventListener('scroll', checkVisibility);
                window.addEventListener('resize', checkVisibility);
                checkVisibility();

                prefetchNextPage();

                window.addEventListener('scroll', () => {
                    const nextPagePreview = document.getElementById('next-page-preview');
                    const nextPagePreviewRect = nextPagePreview.getBoundingClientRect();
                    const previewHeight = nextPagePreviewRect.height;

                    if ((window.innerHeight + window.scrollY) >= (document.body.offsetHeight - previewHeight) && isPreviewFetchNextPage) {
                        window.addEventListener('wheel', disableDownScroll, { passive: false });
                        window.addEventListener('keydown', disableDownScroll, { passive: false });
                    }
                });

                const initialButton = document.querySelector('.load-button');
                attachEventListenersToButton(initialButton);
            });

    </script>
    
    
</body>
</html>