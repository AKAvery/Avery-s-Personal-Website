<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/IndividualProjects/stockSentiment.css') }}">
    <title>Stock Sentiment</title>
</head>
<body>
    <div> 
        <header class="header">
            <a href="/" class="nav-text">Home</a>
            <nav class="nav-bar">
                <a href="/about" class="nav-text">About Me</a>
                <a href="/projects" class="nav-text">Projects</a>
            </nav>
        </header>
        <main id="infinite-content">
            <div style=" text-align: center;">
                <img class="img-background" src="{{ url_for('static', filename='images/positive_data_word_cloud.jpeg') }}" alt="postive data word cloud">
            </div>

            <div class="selector-content">
                <div class="page-row-section">
                    <div style="margin-top: 100px; margin-bottom: 100px; margin-left: 350px; margin-right: 350px;">
                        <p1 class="page-text">In this portfolio project, I explored the use of Natural Language Processing (NLP) and machine learning models to predict stock market trends based on market sentiment. Through this project, I gained hands-on experience with sentiment classification in financial articles, data preprocessing, and model implementation. I worked with various techniques, including Bag-of-Words, logistic regression, Long Short-Term Memory (LSTM) networks, and the Bidirectional Encoder Representations from Transformers (BERT) model. By leveraging these models, I was able to achieve significant improvements in prediction accuracy, demonstrating the potential of NLP in enhancing financial forecasting. Here is a detailed overview of the project, highlighting the methodologies and results obtained. </p>
                    </div>
                </div>
            </div>
            <div class="page-column-section" style="position: relative; height: 100vh;">
                <div class="buffer-zone page-row-section" style="display: flex; align-items: flex-end; height: 100%;"> 
                    <button class="load-button" style="margin-top: auto;">
                        <img class="buffer-img" style="position: relative;" src="{{ url_for('static', filename='images/slim_down_arrow.png') }}">
                    </button>
                    <p class="buffer-text" aria-hidden="true">Placeholder<br>Text</p>
                </div>
            </div>
            <div id="next-page-preview" class="hidden"></div>
        </main>
    </div>

    <div id="loading" style="display: none;">Loading...</div>
    <div id="input-blocker" class="hidden"></div>
    
    <script>
        const pages = [
                '/fistbump',
                '/stockSentiment',
                '/andersonCodingClub'
            ];
            let currentPageIndex = 0;
            let loading = false;
            let nextPageContent = '';
            let isPreviewFetchNextPage = false;
            let initialPageIndex = pages.indexOf(window.location.pathname);

            if (initialPageIndex === -1) {
                initialPageIndex = 0; 
            }

            currentPageIndex = initialPageIndex;

            const disableDownScroll = (event) => {
                if (event.deltaY > 0 || event.key === 'ArrowDown') {
                    event.preventDefault();
                }
            };

            function disableAllScroll() {
                document.body.classList.add('no-scroll');
            };

            function enableScroll() {
                window.removeEventListener('wheel', disableDownScroll, { passive: false });
                window.removeEventListener('keydown', disableDownScroll, { passive: false });
                document.body.classList.remove('no-scroll');
            };

            function blockUserInputs() {
                document.getElementById('input-blocker').classList.add('active');
            };

            function unblockUserInputs() {
                document.getElementById('input-blocker').classList.remove('active');
            };

            const attachEventListenersToButton = (button) => {
                button.addEventListener('mouseover', previewNextPage); 
                button.addEventListener('mouseleave', hideNextPage);   
                button.addEventListener('click', loadMoreContent);      
            };


            const smoothScrollTo = (y, duration, callback) => {
                const infiniteContent = document.getElementById('infinite-content');
                const inputBlocker = document.getElementById('input-blocker');
                const padding = 800;
                infiniteContent.style.paddingTop = `${padding}px`;

                window.scrollTo(0, 0)

                const startY = window.scrollY;
                const distance = y - startY;

                let startTime = null;

                function easeOutCubic(t) {
                    return 1 - Math.pow(1 - t, 3);
                }

                function scrollStep(timestamp) {
                    if (!startTime) startTime = timestamp;
                    const progress = timestamp - startTime;
                    const percent = Math.min(progress / duration, 1);
                    const easedPercent = easeOutCubic(percent);
                    
                    window.scrollTo(0, startY + distance * easedPercent);

                    const exponentialPadding = padding * (1 - easedPercent);
                    infiniteContent.style.paddingTop = `${exponentialPadding}px`;

                    if (progress < duration) {
                        window.requestAnimationFrame(scrollStep);
                    } else {
                        infiniteContent.style.paddingTop = '0px';
                        if (callback) {
                            callback();
                        }
                        unblockUserInputs();
                        enableScroll();
                    }
                }
                blockUserInputs();
                disableAllScroll();
                window.requestAnimationFrame(scrollStep);
            };


            const loadMoreContent = () => {
                if (loading) return;
                loading = true;
                document.getElementById('loading').style.display = 'block';

                blockUserInputs();
                disableAllScroll();


                currentPageIndex = (currentPageIndex + 1) % pages.length;
                fetch(pages[currentPageIndex])
                    .then(response => response.text())
                    .then(data => {
                        const parser = new DOMParser();
                        const newDocument = parser.parseFromString(data, 'text/html');
                        const newContent = newDocument.getElementById('infinite-content').innerHTML;
                        const newContentContainer = document.createElement('div');
                        newContentContainer.innerHTML = newContent;

                        const oldContent = document.querySelectorAll('#infinite-content > div:not(#next-page-preview)');
                        oldContent.forEach(element => element.classList.add('hidden-content'));

                        document.getElementById('infinite-content').appendChild(newContentContainer);
                        document.getElementById('loading').style.display = 'none';
                        loading = false;

                        smoothScrollTo(0, 1000, () => {
                            const oldContent = document.querySelectorAll('#infinite-content > div:not(:last-child)');
                            oldContent.forEach(element => element.classList.add('hidden-content'));
                        });

                        const newButton = newContentContainer.querySelector('.load-button');
                        attachEventListenersToButton(newButton);


                        const newCSSUrl = newDocument.querySelector('link[rel="stylesheet"]').getAttribute('href');
                        document.querySelector('link[rel="stylesheet"]').setAttribute('href', newCSSUrl);

                        prefetchNextPage();

                    })
                    .catch(error => {
                        console.error('Failed to load content:', error);
                        document.getElementById('loading').style.display = 'none';
                        loading = false;
                        unblockUserInputs();
                        enableScroll();
                    });
            };

            function prefetchNextPage() {
                const nextPageIndex = (currentPageIndex + 1) % pages.length;
                fetch(pages[nextPageIndex])
                    .then(response => response.text())
                    .then(data => {
                        const parser = new DOMParser();
                        const newDocument = parser.parseFromString(data, 'text/html');
                        nextPageContent = newDocument.getElementById('infinite-content').innerHTML; 
                    })
                    .catch(error => {
                        console.error('Failed to prefetch next page:', error);
                    });
            };

            function previewNextPage() {
                if (nextPageContent) {
                    const buffEl = document.querySelector('.buffer-zone');
                    buffEl.classList.add('buffer-zone-move');
                    const nextPagePreview = document.getElementById('next-page-preview');
                    nextPagePreview.innerHTML = nextPageContent;
                    nextPagePreview.classList.remove('hidden'); 
                    nextPagePreview.style.display = 'block';
                    nextPagePreview.style.animation = 'scrollUp 0.5s forwards';
                    isPreviewFetchNextPage = true;
                    disableAllScroll();
                } else {
                    console.warn('No content to preview');
                }
            };

            function hideNextPage() {
                const buffEl = document.querySelector('.buffer-zone');
                buffEl.classList.remove('buffer-zone-move');
                const nextPagePreview = document.getElementById('next-page-preview');
                
                nextPagePreview.style.animation = 'scrollOut 0.5s forwards';
                
                nextPagePreview.addEventListener('animationend', () => {
                    nextPagePreview.classList.add('hidden');
                    nextPagePreview.style.display = 'none';
                    enableScroll();

                }, { once: true });
                
                isPreviewFetchNextPage = false;
            };

            document.addEventListener('DOMContentLoaded', () => {
                function checkVisibility() {
                    const elements = document.querySelectorAll('.selector-content');
                    elements.forEach(footerEl => {
                        const rect = footerEl.getBoundingClientRect();
                        if (rect.bottom <= (window.innerHeight + 150)) {
                            footerEl.classList.add('visible-selector-content');
                        }
                    });
                }
                window.addEventListener('scroll', checkVisibility);
                window.addEventListener('resize', checkVisibility);
                checkVisibility();

                prefetchNextPage();

                window.addEventListener('scroll', () => {
                    const nextPagePreview = document.getElementById('next-page-preview');
                    const nextPagePreviewRect = nextPagePreview.getBoundingClientRect();
                    const previewHeight = nextPagePreviewRect.height;

                    if ((window.innerHeight + window.scrollY) >= (document.body.offsetHeight - previewHeight) && isPreviewFetchNextPage) {
                        window.addEventListener('wheel', disableDownScroll, { passive: false });
                        window.addEventListener('keydown', disableDownScroll, { passive: false });
                    }
                });

                const initialButton = document.querySelector('.load-button');
                attachEventListenersToButton(initialButton);
            });

    </script>
    
    
</body>
</html>