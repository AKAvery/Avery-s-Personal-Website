<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/IndividualProjects/stockSentiment.css') }}">
    <title>Stock Sentiment</title>
</head>
<body>
    <div> 
        <header class="header">
            <a href="/" class="nav-text">Home</a>
            <nav class="nav-bar">
                <a href="/about" class="nav-text">About Me</a>
                <a href="/projects" class="nav-text">Projects</a>
            </nav>
        </header>
        <main id="infinite-content">
            <div style="margin-top: 50px; text-align: center;">
                <img class="img-background" src="{{ url_for('static', filename='images/positive_data_word_cloud.jpeg') }}" alt="postive data word cloud">
            </div>

            <div class="selector-content">
                <div class="page-row-section">
                    <div style="margin-top: 100px; margin-bottom: 100px; margin-left: 350px; margin-right: 350px;">
                        <p1 class="page-text">In this portfolio project, I explored the use of Natural Language Processing (NLP) and machine learning models to predict stock market trends based on market sentiment. Through this project, I gained hands-on experience with sentiment classification in financial articles, data preprocessing, and model implementation. I worked with various techniques, including Bag-of-Words, logistic regression, Long Short-Term Memory (LSTM) networks, and the Bidirectional Encoder Representations from Transformers (BERT) model. By leveraging these models, I was able to achieve significant improvements in prediction accuracy, demonstrating the potential of NLP in enhancing financial forecasting. Here is a detailed overview of the project, highlighting the methodologies and results obtained. </p>
                    </div>
                </div>
            </div>
            <div class="selector-content">
                <div class="page-row-section" style="margin-bottom: 100px;">
                    Hellow, I don't really know what ot put her but i am going to type as a texst and I will fill this in with more informaiton Later. I think that I am watkching tennis right now and musetti just hit the craziest backhadn overhaead
                </div>
            </div>
            <div class="buffer-zone page-row-section"> 
                <button class="load-button">
                    <img style="position: relative;" src="{{ url_for('static', filename='images/arrow_down.png') }}">
                </button>
            </div>
            <div id="next-page-preview" class="hidden"></div>
        </main>
    </div>

    <div id="loading" style="display: none;">Loading...</div>
    <div id="input-blocker" class="hidden"></div>
    
    <script>
        const pages = [
            '/fistbump',
            '/stockSentiment',
            '/andersonCodingClub'
        ];
        let currentPageIndex = 0;
        let loading = false;
        let nextPageContent = '';
        let isPreviewFetchNextPage = false;

        const disableDownScroll = (event) => {
            if (event.deltaY > 0 || event.key === 'ArrowDown') {
                event.preventDefault();
            }
        };

        const disableAllScroll = () => {
            document.body.classList.add('no-scroll');
        };

        const enableScroll = () => {
            window.removeEventListener('wheel', disableDownScroll, { passive: false });
            window.removeEventListener('keydown', disableDownScroll, { passive: false });
            document.body.classList.remove('no-scroll');
        };

        const blockUserInputs = () => {
            document.getElementById('input-blocker').classList.add('active');
        };

        const unblockUserInputs = () => {
            document.getElementById('input-blocker').classList.remove('active');
        };

        const attachEventListenersToButton = (button) => {
            button.addEventListener('mouseover', previewNextPage);  // Attach mouseover event
            button.addEventListener('mouseleave', hideNextPage);    // Attach mouseleave event
            button.addEventListener('click', loadMoreContent);      // Attach click event
        };


        const smoothScrollTo = (y, duration, callback) => {
        const startY = window.scrollY;
        const distance = y - startY;
        let startTime = null;

        function scrollStep(timestamp) {
            if (!startTime) startTime = timestamp;
            const progress = timestamp - startTime;
            const percent = Math.min(progress / duration, 1);
            window.scrollTo(0, startY + distance * percent);
            if (progress < duration) {
                window.requestAnimationFrame(scrollStep);
            } else if (callback) {
                callback();
            }
        }

        window.requestAnimationFrame(scrollStep);
    };

        const loadMoreContent = () => {
            if (loading) return;
            loading = true;
            document.getElementById('loading').style.display = 'block';

            currentPageIndex = (currentPageIndex + 1) % pages.length;
            fetch(pages[currentPageIndex])
                .then(response => response.text())
                .then(data => {
                    const parser = new DOMParser();
                    const newDocument = parser.parseFromString(data, 'text/html');
                    const newContent = newDocument.getElementById('infinite-content').innerHTML;
                    const newContentContainer = document.createElement('div');
                    newContentContainer.innerHTML = newContent;

                    const oldContent = document.querySelectorAll('#infinite-content > div:not(#next-page-preview)');
                    oldContent.forEach(element => element.classList.add('hidden-content'));

                    document.getElementById('infinite-content').appendChild(newContentContainer);
                    document.getElementById('loading').style.display = 'none';
                    loading = false;

                    const scrollToY = newContentContainer.offsetTop - 200;
                    smoothScrollTo(scrollToY, 1000, () => {
                        // Smoothly scroll down by 200 pixels
                        smoothScrollTo(scrollToY + 200, 500, () => {
                            // Hide old content after scrolling
                            const oldContent = document.querySelectorAll('#infinite-content > div:not(:last-child)');
                            oldContent.forEach(element => element.classList.add('hidden-content'));
                        });
                    });

                    enableScroll();

                    // Attach event listeners to the new load button in the newly loaded content
                    const newButton = newContentContainer.querySelector('.load-button');
                    attachEventListenersToButton(newButton);

                    prefetchNextPage();

                    const checkScrollPosition = () => {
                        if (window.scrollY >= scrollToY + 200) {
                            unblockUserInputs(); // Unblock user inputs
                            window.removeEventListener('scroll', checkScrollPosition); // Remove the event listener
                        }
                    };

                    window.addEventListener('scroll', checkScrollPosition); // Add the event listener
                })
                .catch(error => {
                    console.error('Failed to load content:', error);
                    document.getElementById('loading').style.display = 'none';
                    loading = false;
                    enableScroll();
                });
        };

        const prefetchNextPage = () => {
            const nextPageIndex = (currentPageIndex + 1) % pages.length;
            fetch(pages[nextPageIndex])
                .then(response => response.text())
                .then(data => {
                    const parser = new DOMParser();
                    const newDocument = parser.parseFromString(data, 'text/html');
                    nextPageContent = newDocument.getElementById('infinite-content').innerHTML; // Store the pre-fetched content
                })
                .catch(error => {
                    console.error('Failed to prefetch next page:', error);
                });
        };

        const previewNextPage = () => {
            if (nextPageContent) {
                const nextPagePreview = document.getElementById('next-page-preview');
                nextPagePreview.innerHTML = nextPageContent; // Set the inner HTML for the preview
                nextPagePreview.classList.remove('hidden');  // Remove 'hidden' class to show the preview
                nextPagePreview.style.display = 'block'; // Make sure it's displayed
                isPreviewFetchNextPage = true;
                disableAllScroll(); // Disable scrolling
            } else {
                console.warn('No content to preview');
            }
        };

        const hideNextPage = () => {
            const nextPagePreview = document.getElementById('next-page-preview');
            nextPagePreview.classList.add('hidden');  // Add 'hidden' class to hide the preview
            nextPagePreview.style.display = 'none'; // Make sure it's hidden
            isPreviewFetchNextPage = false;
            enableScroll(); // Re-enable scrolling
        };

        document.addEventListener('DOMContentLoaded', () => {
            function checkVisibility() {
                const elements = document.querySelectorAll('.selector-content');
                elements.forEach(footerEl => {
                    const rect = footerEl.getBoundingClientRect();
                    if (rect.bottom <= (window.innerHeight + 150)) {
                        footerEl.classList.add('visible-selector-content');
                    }
                });
            }
            window.addEventListener('scroll', checkVisibility);
            window.addEventListener('resize', checkVisibility);
            checkVisibility();

            prefetchNextPage();

            window.addEventListener('scroll', () => {
                const nextPagePreview = document.getElementById('next-page-preview');
                const nextPagePreviewRect = nextPagePreview.getBoundingClientRect();
                const previewHeight = nextPagePreviewRect.height;

                if ((window.innerHeight + window.scrollY) >= (document.body.offsetHeight - previewHeight) && isPreviewFetchNextPage) {
                    window.addEventListener('wheel', disableDownScroll, { passive: false });
                    window.addEventListener('keydown', disableDownScroll, { passive: false });
                }
            });

            const initialButton = document.querySelector('.load-button');
            attachEventListenersToButton(initialButton); // Attach event listeners to the initial load button
        });
    


        /*window.addEventListener('scroll', () => {
                if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - 500) {
                    loadMoreContent();
                }
            });*/

        
    

    
        /*document.addEventListener('DOMContentLoaded', () => {
            const pages = [
                '/fistbump',
                '/stockSentiment'
            ];
            let currentPageIndex = 0;
            let loading = false;
            let bufferReached = false;
            let scrollCount = 0;
            let lastScrollTime = 0;
            let scrollFactor = 0.5;
            let slowScrollEnabled = true;

            const freezeScroll = () => {
                document.body.classList.add('no-scroll');
            };

            const unfreezeScroll = () => {
                document.body.classList.remove('no-scroll');
            };

            const loadMoreContent = () => {
                if (loading || scrollCount < 1) return;
                loading = true;
                document.getElementById('loading').style.display = 'block';

                currentPageIndex = (currentPageIndex + 1) % pages.length;
                fetch(pages[currentPageIndex])
                    .then(response => response.text())
                    .then(data => {
                        const parser = new DOMParser();
                        const newDocument = parser.parseFromString(data, 'text/html');
                        const newContent = newDocument.getElementById('infinite-content').innerHTML;
                        const newContentContainer = document.createElement('div');
                        newContentContainer.innerHTML = newContent;
                        document.getElementById('infinite-content').appendChild(newContentContainer);
                        document.getElementById('loading').style.display = 'none';
                        loading = false;
                        bufferReached = false;
                        scrollCount = 0;

                        slowScrollEnabled = false;
                        setTimeout(() => {
                            slowScrollEnabled = true;
                        }, 1000);

                        window.scrollTo({ top: newContentContainer.offsetTop, behavior: 'smooth' });
                    })
                    .catch(() => {
                        document.getElementById('loading').style.display = 'none';
                        loading = false;
                        bufferReached = false;
                    });
            };

            const bufferZone = document.getElementById('buffer-zone');
            const slowScrollContainer = document.getElementById('slow-scroll');

            window.addEventListener('scroll', () => {
                const now = Date.now();
                if (now - lastScrollTime < 200) return;
                lastScrollTime = now;

                const rect = bufferZone.getBoundingClientRect();
                if ((rect.bottom - 200) <= window.innerHeight && !bufferReached) {
                    bufferReached = true;
                    scrollCount = 0;
                    window.scrollBy({ top: -200, behavior: 'smooth' });
                    freezeScroll();
                    setTimeout(() => {
                        unfreezeScroll();
                        window.addEventListener('wheel', smoothScroll);
                    }, 1000);
                }

                else if (!bufferReached) {
                    window.removeEventListener('wheel', smoothScroll);
                }

            });

            const smoothScroll = (event) => {
                const slowScrollRect = slowScrollContainer.getBoundingClientRect();
                if (slowScrollEnabled && slowScrollRect.top <= window.innerHeight && slowScrollRect.bottom >= window.innerHeight) {
                    event.preventDefault();
                    const targetScroll = window.scrollY + event.deltaY * scrollFactor;
                    window.requestAnimationFrame(() => {
                        window.scrollTo({
                            top: targetScroll,
                            behavior: 'smooth'
                        });
                    });
                } 
                
                if (bufferReached && event.deltaY > 0) { 
                    scrollCount++;
                    if (scrollCount >= 1 && !loading) {
                        loadMoreContent();
                    }
                }
            };

            window.addEventListener('touchmove', () => {
                if (bufferReached) {
                    scrollCount++;
                    if (scrollCount >= 1 && !loading) {
                        loadMoreContent();
                    }
                }
            });
        });*/

    </script>
    
    
</body>
</html>